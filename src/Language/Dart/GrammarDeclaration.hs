{-# LANGUAGE RankNTypes, TemplateHaskell, TypeFamilies #-}

module Language.Dart.GrammarDeclaration where

import Control.Applicative
import Control.Monad (guard)
import Data.Char (isAlphaNum, isLetter, isSpace)
import Data.Monoid (Endo(..), (<>))
import Text.Grampa hiding (Grammar)
import Text.Grampa.ContextFree.LeftRecursive (Parser)
import qualified Text.Grampa as Lexical (identifier)
import qualified Text.Grampa as Grampa
import Text.Parser.Combinators (try)
import Language.Dart.Syntax

import qualified Rank2
import qualified Rank2.TH

import Prelude hiding (exponent)

data Grammar p = Grammar {
   typedLiteral :: p TypedLiteral,
   mapLiteral :: p TypedLiteral,
   listLiteral :: p TypedLiteral,
   interpolationExpression :: p InterpolationElement,
   interpolationStringNoSingleQuote :: p InterpolationElement,
   interpolationStringNoDoubleQuote :: p InterpolationElement,
   characterEscape :: p Char,
   singleStringLiteral :: p StringLiteral,
   simpleStringLiteral :: p String,
   rawStringLiteral :: p String,
   basicStringLiteral :: p String,
   multiLineStringLiteral :: p String,
   singleLineStringLiteral :: p String,
   stringInterpolation :: p [InterpolationElement],
   stringLiteral :: p StringLiteral,
   adjacentStrings :: p [StringLiteral],
   literal :: p Literal,
   booleanLiteral :: p Bool,
   doubleLiteral :: p Double,
   exponent :: p String,
   integerLiteral :: p Integer,
   decimalIntegerLiteral :: p Integer,
   hexadecimalIntegerLiteral :: p Integer,
   nullLiteral :: p Literal,
   symbolLiteral :: p [Token],
   variableDeclaration :: p VariableDeclaration,
   variableDeclarationList :: p VariableDeclarationList,
   finalConstVarOrType :: p FinalConstVarOrType,
   declaredIdentifier :: p DeclaredIdentifier,
   functionDeclaration :: p FunctionDeclaration,
   functionSignature :: p ((Maybe TypeName -> PropertyKeyword -> SimpleIdentifier -> FunctionExpression 
                            -> FunctionDeclaration)
                           -> FunctionBody -> FunctionDeclaration),
   withClause :: p WithClause,
   implementsClause :: p ImplementsClause,
   typeAlias :: p NamedCompilationUnitMember,
   typeAliasBody :: p TypeAlias,
   classTypeAlias :: p TypeAlias,
--   mixinApplication :: p MixinApplication,
   functionTypeAlias :: p TypeAlias,
--   functionPrefix :: p FunctionPrefix,
   classDeclaration :: p NamedCompilationUnitMember,
   classMember :: p ClassMember,
   enumType :: p NamedCompilationUnitMember,
   compilationUnitMember :: p CompilationUnitMember,
   topLevelVariableDeclaration :: p CompilationUnitMember,
   constructorDeclaration :: p ClassMember,
   constructorSignature :: p (Maybe FunctionBody -> ClassMember),
   constructorName :: p (Identifier, Maybe SimpleIdentifier),
   constructorDesignation :: p ConstructorName,
   factoryName :: p (Identifier, Maybe SimpleIdentifier),
   initializerList :: p [ConstructorInitializer],
   methodDeclaration :: p ClassMember,
   methodSignature :: p (FunctionBody -> ClassMember),
   methodName :: p (Bool, SimpleIdentifier),
   fieldDeclaration :: p ClassMember,
   exportDirective :: p NamespaceDirective,
   importDirective :: p NamespaceDirective,
   uriBasedDirective :: p UriBasedDirective,
   partDirective :: p UriBasedDirective,
   directive :: p Directive,
   partOfDirective :: p Directive,
   libraryDirective :: p Directive,
   constructorInitializer :: p ConstructorInitializer,
   redirectingConstructorInvocation :: p ConstructorInitializer,
   fieldInitializer :: p ConstructorInitializer,
   superInvocation :: p ConstructorInitializer,
   combinator :: p Combinator,
   showCombinator :: p Combinator,
   hideCombinator :: p Combinator,
--   dottedName :: p DottedName,
--   configuration :: p Configuration,
--   test :: p (DottedName, StringLiteral),
   extendsClause :: p ExtendsClause,
   mapLiteralEntry :: p MapLiteralEntry,
   scriptTag :: p ScriptTag,
   nativeClause :: p AstNode,
   normalFormalParameter :: p NormalFormalParameter,
   functionTypedFormalParameter :: p NormalFormalParameter,
   fieldFormalParameter :: p NormalFormalParameter,
   simpleFormalParameter :: p NormalFormalParameter,
   formalParameter :: p FormalParameter,
   defaultFormalParameter :: p FormalParameter,
--   defaultNamedParameter :: p FormalParameter,
   formalParameterList :: p FormalParameterList,
   normalFormalParameters :: p [FormalParameter],
   optionalFormalParameters :: p [FormalParameter],
   optionalPositionalFormalParameters :: p [FormalParameter],
   namedFormalParameters :: p [FormalParameter],
   typeParameter :: p TypeParameter,
   typeParameterList :: p TypeParameterList,
   argumentList :: p ArgumentList,
   arguments :: p ArgumentList,
   commentReference :: p CommentReference,
   comment :: p String,
   documentationComment :: p String,
   metadata :: p [Annotation],
   annotation :: p Annotation,
   label :: p Label,
   typeName :: p TypeName,
   typeArguments :: p TypeArgumentList,
   switchMember :: p SwitchMember,
   switchDefault :: p SwitchMember,
   switchCase :: p SwitchMember,
   onPart :: p CatchClause,
   catchPart :: p (SimpleIdentifier, Maybe SimpleIdentifier),
   block :: p Block,
   simpleIdentifier :: p SimpleIdentifier,
   libraryIdentifier :: p LibraryIdentifier,
   identifier :: p Identifier,
   prefixedIdentifier :: p Identifier,
   functionBody :: p FunctionBody,
   blockFunctionBody :: p FunctionBody,
   emptyFunctionBody :: p FunctionBody,
   expressionFunctionBody :: p FunctionBody,
   nativeFunctionBody :: p FunctionBody,
   functionExpression :: p FunctionExpression,
   functionExpressionWithoutCascade :: p FunctionExpression,
   functionExpressionWithoutCascadeBody :: p FunctionBody,
   functionPrimary :: p FunctionExpression,
--   constructorName :: p ConstructorName,
   functionExpressionInvocation :: p InvocationExpression,
   methodInvocation :: p InvocationExpression,
   expression :: p Expression,
   expressionWithoutCascade :: p Expression,
--   prefixExpression :: p Expression,
   postfixExpression :: p Expression,
--   binaryExpression :: p Expression,
   unaryExpression:: p Expression,
--   assignmentExpression :: p Expression,
   newExpression :: p Expression,
--   asExpression :: p Expression,
--   isExpression :: p Expression,
   throwExpression :: p Expression,
   throwExpressionWithoutCascade :: p Expression,
--   rethrowExpression :: p Expression,
   thisExpression :: p Expression,
--   superExpression :: p Expression,
--   parenthesizedExpression :: p Expression,
--   propertyAccess :: p Expression,
   namedExpression :: p Expression,
   constObjectExpression :: p Expression,
   conditionalExpression :: p Expression,
--   cascadeExpression :: p Expression,
   cascadeSection :: p Expression,
   cascadeSelector :: p Expression,
   selector :: p (Endo Expression),
   assignableExpression :: p Expression,
   assignableSelector :: p (Endo Expression),
   assignableSelectorPart :: p (Endo Expression),
   unconditionalAssignableSelector :: p (Endo Expression),
   argumentPart :: p (Endo Expression),
   ifNullExpression :: p Expression,
   logicalOrExpression :: p Expression,
   logicalAndExpression :: p Expression,
   equalityExpression :: p Expression,
   relationalExpression :: p Expression,
   additiveExpression :: p Expression,
   multiplicativeExpression :: p Expression,
   shiftExpression :: p Expression,
   bitwiseOrExpression :: p Expression,
   bitwiseXorExpression :: p Expression,
   bitwiseAndExpression :: p Expression,
   primary :: p Expression,
--   indexExpression :: p Expression,
   awaitExpression :: p Expression,
   statement :: p Statement,
   variableDeclarationStatement :: p Statement,
   forStatement :: p Statement,
   forLoopParts :: p (Statement -> Statement),
   forInitializerStatement :: p (Maybe VariableDeclarationList, Maybe Expression),
   forEachStatement :: p Statement,
   whileStatement :: p Statement,
   doStatement :: p Statement,
   switchStatement :: p Statement,
   ifStatement :: p Statement,
   tryStatement :: p Statement,
   finallyClause :: p Block,
   breakStatement :: p Statement,
   continueStatement :: p Statement,
   returnStatement :: p Statement,
   expressionStatement :: p Statement,
   assertStatement :: p Statement,
   yieldStatement :: p Statement,
   emptyStatement :: p Statement,
   labeledStatement :: p Statement,
   compilationUnit :: p CompilationUnit,
   directives :: p ([CompilationUnitMember] -> CompilationUnit),
   namespaceDirective :: p NamespaceDirective,
   declarations :: p [CompilationUnitMember],
   additiveOperator :: p String,
   assignmentOperator :: p String,
   compoundAssignmentOperator :: p String,
   equalityOperator :: p String,
   incrementOperator :: p String,
   minusOperator :: p String,
   multiplicativeOperator :: p String,
   negationOperator :: p String,
   postfixOperator :: p String,
   prefixOperator :: p String,
   relationalOperator :: p String,
   shiftOperator :: p String,
   tildeOperator :: p String,
   binaryOperator :: p String,
   bitwiseOperator :: p String,
   operator :: p String}

$(Rank2.TH.deriveAll ''Grammar)

instance Lexical Grammar where
   type LexicalConstraint p Grammar s = (s ~ String, p ~ Parser)
   lexicalComment = () <$ (endOfLineComment <|> blockComment)
   lexicalWhiteSpace = takeCharsWhile isSpace *> skipMany (lexicalComment *> takeCharsWhile isSpace)
   isIdentifierStartChar c = isLetter c || c == '_' || c == '$'
   isIdentifierFollowChar c = isAlphaNum c || c == '_' || c == '$'
   identifierToken word = lexicalToken $
                          try (do w <- word
                                  guard (w `notElem` reservedWords)
                                  return w)

reservedWords :: [String]
reservedWords = ["abstract", "as", "assert", "async", "await", "break",
                 "case", "catch", "class", "const", "continue", "covariant", 
                 "default", "deferred", "do", "dynamic",
                 "else", "enum", "export", "extends", "external", 
                 "factory", "false", "final", "finally", "for", "function",
                 "get", "hide", 
                 "if", "implements", "import", "in", "is", "library", 
                 "new", "null", "of", "on", "operator", 
                 "part", "rethrow", "return", 
                 "set", "show", "static", "super", "switch", "sync", 
                 "this", "throw", "true", "try", "typedef", 
                 "var", "void", "while", "with", "yield"]

endOfLineComment, blockComment :: Parser Grammar String String
endOfLineComment= string "//" *> takeCharsWhile (/= '\n') <* char '\n'
blockComment=
      string "/--  "
   *> concatMany (notFollowedBy (string "*/") *> anyToken <> takeCharsWhile (/= '*'))
   <* string "*/"
